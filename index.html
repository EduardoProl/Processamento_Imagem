<!DOCTYPE html>
<html lang="pt-PT">

<!-- Incluir CSS e JS do CodeMirror -->
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.64.0/codemirror.min.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.64.0/theme/dracula.min.css"> <!-- Tema escuro -->

<script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.64.0/codemirror.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.64.0/mode/python/python.min.js"></script> <!-- Para destacar Python -->

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>P.I. LEIC</title>
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <header>
        <button id="menuButton">
            <img src="https://img.icons8.com/?size=100&id=eofQ1g5BaAx6&format=png&color=000000" alt="Menu Icon" />
        </button>
        <h1>Processamento de Imagem - LEIC 2024/2025<h1>
    </header>

    <!-- Side Navigation -->
    <div id="sideNav">
        <text class='index_title'>Básico:</text>    
        <hr>
        <a href="#Abrir_imagens">Abrir Imagens</a>
        <br>
        <text class='index_title'>Centroides e Momentos da imagem:</text>
        <hr>
        <a href="#codeSection">Centroides</a>
        <a href="#codeSection1">Momentos Centrados</a>
        <a href="#codeSection2">Orientação</a>
        <a href="#codeSection3">Desenhar linha com base no angulo</a>
        <a href="#codeSection4">Excentricidade</a>
        <br>
        <text class='index_title'>Filtragem:</text>
        <hr>
        <a href="#Dil_ero">Dilate e Erode</a>
        <a href="#Eliminar_Ruido">Eliminar Ruido com dilate e erode</a>
        <a href="#Brilho_GAMA">Brilho, contraste e Gama</a>
        <a href="#BLUR_INT">Blur integral</a>
        <a href="#BLUR_GAUSS">Blur gaussiano</a>
    </div>

    <main>
        <hr>
        <text class="titulo">Básico:</text>
        <hr>
        <section id="Abrir_imagens">
            <h2>Abrir Imagens</h2>
            <div class="code-container">
                <!-- Alterado para textarea -->
                <textarea id="codeBox3" class="codeBox">
img = plt.imread("../imagens/imagem_a.jpg")
                </textarea>
                <button class="copyButton">Copiar</button>
            </div>
        </section>

        <hr>
        <text class="titulo">Momentos da Imagem:</text>
        <hr>
        <section id="codeSection">
            <h2>Centroides</h2>
            <div class="code-container">
                <!-- Alterado para textarea -->
                <textarea id="codeBox1" class="codeBox">def centroide(imagem_hex):
M00 = M01 = M10 = 0

for i in range(imagem_hex.shape[0]):
    for j in range(imagem_hex.shape[1]):
        M00 += imagem_hex[i, j]
        M01 += (imagem_hex[i, j] * j)
        M10 += (imagem_hex[i, j] * i)
return M01 / M00, M10 / M00
                </textarea>
                <button class="copyButton">Copiar</button>
            </div>
        </section>

        <section id="codeSection1">
            <h2>Momentos Centrados</h2>
            <div class="code-container">
                <!-- Alterado para textarea -->
                <textarea id="codeBox2" class="codeBox">def momentos_centrados(img):
"""Calcula os momentos centrais de segunda ordem mu11, mu02, mu20."""
y, x = centroide(img)
mu11 = mu02 = mu20 = 0
for i in range(img.shape[0]):
    for j in range(img.shape[1]):
        mu11 += (i - x) * (j - y) * img[i, j]
        mu02 += (i - y) ** 2 * img[i, j]
        mu20 += (j - x) ** 2 * img[i, j]
return mu11, mu02, mu20
                </textarea>
                <button class="copyButton">Copiar</button>
            </div>
        </section>

        <section id="codeSection2">
            <h2>Orientação</h2>
            <div class="code-container">
                <!-- Alterado para textarea -->
                <textarea id="codeBox3" class="codeBox">def calcular_orientacao(img):
    mu11, mu02, mu20 = momentos_centrados(img)
    # Calcular a orientação (em radianos)
    theta = 0.5 * np.arctan2(2 * mu11, (mu20 - mu02))
    return np.degrees(theta) # Retorna a orientação em graus
                </textarea>
                <button class="copyButton">Copiar</button>
            </div>
        </section>

        <section id="codeSection3">
            <h2>Desenhar linha com base no angulo</h2>
            <div class="code-container">
                <!-- Alterado para textarea -->
                <textarea id="codeBox4" class="codeBox">def desenhar_linha(x, y, theta, comprimento=150, cor='red'):
    # Convertendo ângulo para radianos
    theta_rad = np.radians(theta)
    
   # Calculando os componentes de deslocamento da seta (dx, dy)
    dx = comprimento * np.cos(theta_rad)
    dy = -comprimento * np.sin(theta_rad)  
    # Desenhando a seta com plt.arrow
    plt.arrow(x, y, dx, dy, head_width=15, head_length=10, fc=cor, ec=cor)
                </textarea>
                <button class="copyButton">Copiar</button>
            </div>
        </section>

        <section id="codeSection4">
            <h2>Excentricidade</h2>
            <div class="code-container">
                <!-- Alterado para textarea -->
                <textarea id="codeBox5" class="codeBox">def calcular_excentricidade(img):
    """Calcula a excentricidade da figura com base nos momentos centrais."""
    mu11, mu02, mu20 = momentos_centrados(img)
    
    # Matriz de covariância dos momentos centrais
    cov_matrix = np.array([[mu20, mu11],
                           [mu11, mu02]])
    
    # Calculando os autovalores da matriz de covariância
    eigenvalues, _ = np.linalg.eig(cov_matrix)
    
    # Ordenando os autovalores para garantir que lambda1 >= lambda2
    lambda1, lambda2 = sorted(eigenvalues, reverse=True)
    
    # Excentricidade
    excentricidade = np.sqrt(1 - (lambda2 / lambda1))
    return excentricidade
                </textarea>
                <button class="copyButton">Copiar</button>
            </div>
        </section>
        <hr>
        <text class="titulo">Filtragem:</text>
        <hr>
        <section id="Dil_ero">
            <h2>Dilate e Erode</h2>
            <div class="code-container">
                <!-- Alterado para textarea -->
                <textarea id="codeBox5" class="codeBox">
I_dilate = sc.binary_dilation(Img,structure = np.ones((5,5)))
I_eroded = sc.binary_erosion(Img,structure = np.ones((9,9)))
                </textarea>
                <button class="copyButton">Copiar</button>
            </div>
        </section>

        <section id="Eliminar_Ruido">
            <h2>Eliminar Ruido</h2>
            <div class="code-container">
                <!-- Alterado para textarea -->
                <textarea id="codeBox5" class="codeBox">
I_dilate = sc.binary_dilation(Iseg,structure = np.ones((5,5)))
I_eroded = sc.binary_erosion(I_dilate,structure = np.ones((9,9)))
I_final = sc.binary_dilation(I_eroded,structure = np.ones((5,5)))
                </textarea>
                <button class="copyButton">Copiar</button>
            </div>
        </section>

        <section id="Brilho_GAMA">
            <h2>Brilho, Contraste e Gama</h2>
            <div class="code-container">
                <!-- Alterado para textarea -->
                <textarea id="codeBox5" class="codeBox">
import matplotlib.pyplot as plt
import numpy as np

# Brilho
imagem = plt.imread("car.jpg")
imagem = imagem.astype(np.float32)
brilho = 30
imagem_brilho = imagem + brilho
imagem_brilho = np.clip(imagem_brilho, 0, 255)
imagem_brilho = imagem_brilho.astype(np.uint8)

#Contraste
imagem = plt.imread("car.jpg")
imagem = imagem.astype(np.float32)
alpha = 1.5
imagem_contraste = imagem * alpha
imagem_contraste = np.clip(imagem_contraste, 0, 255)
imagem_contraste = imagem_contraste.astype(np.uint8)
                    
#Gama
imagem = plt.imread("car.jpg") #Load the image
imagem = imagem.astype(np.float32) / 255.0  #Normalize to range [0, 1]
gamma = 2.2
imagem_gama = np.power(imagem, gamma) #Apply gamma correction
imagem = (imagem * 255).astype(np.uint8) #Scale back to [0, 255] and convert to uint8
imagem_gama = (imagem_gama * 255).clip(0, 255).astype(np.uint8)
                
                </textarea>
                <button class="copyButton">Copiar</button>
            </div>
        </section>

        <section id="BLUR_INT">
            <h2>Blur Integral</h2>
            <div class="code-container">
                <!-- Alterado para textarea -->
                <textarea id="codeBox5" class="codeBox">
import matplotlib.pyplot as plt
import numpy as np

def integral_image(imagem_gray):
    integral_img = np.zeros_like(imagem_gray)

    # Primeiro pixel
    integral_img[0, 0] = imagem_gray[0, 0]

    # Primeira linha
    for j in range(1, imagem_gray.shape[1]):
        integral_img[0, j] = integral_img[0, j-1] + imagem_gray[0, j]

    # Primeira coluna
    for i in range(1, imagem_gray.shape[0]):
        integral_img[i, 0] = integral_img[i-1, 0] + imagem_gray[i, 0]

    # Restantes pixeis 
    for i in range(1, imagem_gray.shape[0]):
        for j in range(1, imagem_gray.shape[1]):
            integral_img[i, j] = imagem_gray[i, j] + integral_img[i-1, j] + integral_img[i, j-1] - integral_img[i-1, j-1]

    return integral_img

def soma_regiao_integral(integral_img, x1, y1, x2, y2):
    total = integral_img[y2, x2]

    if x1 > 0:
        total -= integral_img[y2, x1 - 1]
    if y1 > 0:
        total -= integral_img[y1 - 1, x2]
    if x1 > 0 and y1 > 0:
        total += integral_img[y1 - 1, x1 - 1]

    return total

def blur(imagem_gray, integral_img, window_size):
    blurred_image = np.zeros_like(imagem_gray)
    half_window = window_size // 2

    for i in range(imagem_gray.shape[0]):
        for j in range(imagem_gray.shape[1]):
            x1 = j - half_window
            if x1 < 0: x1 = 0
            
            y1 = i - half_window
            if y1 < 0: y1 = 0
            
            x2 = j + half_window
            if x2 >= imagem_gray.shape[0]: x2 = imagem_gray.shape[0] - 1
            
            y2 = i + half_window
            if y2 >= imagem_gray.shape[1]: y2 = imagem_gray.shape[1] - 1
            
            blurred_image[i, j] = soma_regiao_integral(integral_img, x1, y1, x2, y2) / ((x2 - x1 + 1) * (y2 - y1 + 1))

    return blurred_image

imagem = plt.imread("barco.jpg")
height, width  , channel = imagem.shape 
imagem_gray= np.mean(imagem,axis=2) #Torna imagem em gray scale 
integral_img  = integral_image(imagem_gray)
blurred_img = blur(imagem_gray, integral_img ,30)
                
                </textarea>
                <button class="copyButton">Copiar</button>
            </div>
        </section>

        <section id="BLUR_GAUSS">
            <h2>Blurr Gaussiano</h2>
            <div class="code-container">
                <!-- Alterado para textarea -->
                <textarea id="codeBox5" class="codeBox">
import matplotlib.pyplot as plt
import numpy as np
def gaussian(imagem_gray):
    gaussian_matrix = np.array([[1, 4, 6, 4, 1],
                                [4, 16, 24, 16, 4],
                                [6, 24, 36, 26, 6],
                                [4, 16, 24, 16, 4],
                                [1, 4, 6, 4, 1]])

    filtered_img = np.zeros_like(imagem_gray)
    window_height, window_width = gaussian_matrix.shape

    padded_image = np.pad(imagem_gray, 
                            ((window_height // 2, window_height // 2), 
                            (window_width // 2, window_width // 2)),
                            mode='constant', constant_values=0)
    total = np.sum(gaussian_matrix)
    for i in range(imagem_gray.shape[0]):
        for j in range(imagem_gray.shape[1]):
            window = padded_image[i:i+window_height, j:j+window_width]
            filtered_img[i, j] = np.sum(window * gaussian_matrix) / total
    
    return filtered_img

def sharpen(imagem_gray):
    # Define the sharpening filter (kernel)
    sharpening_kernel = np.array([[0, -1,  0],
                                    [-1,  5, -1],
                                    [0, -1,  0]])

    filtered_img = np.zeros_like(imagem_gray)
    window_height, window_width = sharpening_kernel.shape

    padded_image = np.pad(imagem_gray, 
                            ((window_height // 2, window_height // 2), 
                            (window_width // 2, window_width // 2)),
                            mode='constant', constant_values=0)

    for i in range(imagem_gray.shape[0]):
        for j in range(imagem_gray.shape[1]):
            window = padded_image[i:i+window_height, j:j+window_width]
            
            filtered_img[i, j] = np.sum(window * sharpening_kernel)
    
    return filtered_img

def equation_sharpe(imagem_gray , blurred_img ):
    alpha = 0.5
    return (imagem_gray + alpha*(imagem_gray-blurred_img))

imagem = plt.imread("PCB.jpg")
imagem_gray= np.mean(imagem,axis=2) #Torna imagem em gray scale 
blurred_img = gaussian(imagem_gray)

#sharpened_img = sharpen(blurred_img)
sharpened_img = equation_sharpe(imagem_gray , blurred_img )
                
                </textarea>
                <button class="copyButton">Copiar</button>
            </div>
        </section>

    </main>

    <script src="script.js"></script>
</body>
</html>
    